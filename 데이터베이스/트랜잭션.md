# 트랜잭션

```
데이터베이스의 상태를 변환시키는 하나의 논리적 기능을 수행하기 위한 작업의 단위
또는 한꺼번에 모두 수행되어야 할 일련의 연산들을 의미
```

## 트랜잭션의 특징

1. 데이터베이스 시스템에서 병행 제어 및 회복 작업 시 처리되는 작업의 논리적 단위이다.
2. 사용자가 시스템에 대한 서비스 요구 시 시스템이 응답하기 위한 상태 변환 과정의 작업단위이다.
3. 하나의 트랜잭션은 Commit 되거나 Rollback 된다.

---

## 트랜잭션의 성질

### 원자성

1. 트랜잭션의 연산은 데이터베이스에 모두 반영되든지 아니면 전혀 반영되지 않아야 한
   다.
2. 트랜잭션 내의 모든 명령은 반드시 완벽히 수행되어야 하며, 모두가 완벽히 수행되지 않고 어느 하나라도 오류가 발생하면 트랜잭션 전부가 취소되어야 한다.

---

### 일관성

1. 트랜잭션이 그 실행을 성공적으로 완료하면 언제나 일관성 있는 데이터베이스 상태로 변환한다.
2. 시스템이 가지고 있는 고정요소는 트랜잭션 수행 전과 트랜잭션 수행 완료 후의 상태가 같아야 한다.

---

### 독립성, 격리성

1. 둘 이상의 트랜잭션이 동시에 병행 실행되는 경우 어느 하나의 트랜잭션 실행 중에 다른 트랜잭션의 연산이 끼어들 수 없다.
2. 수행중인 트랜잭션은 완전히 완료될 때 까지 다른 트랜잭션에서 수행 결과를 참조할 수 없다.

---

### 영속성, 지속성

1. 성공적으로 완료된 트랜잭션의 결과는 시스템이 고장나더라도 영구적으로 반영되어야 한다.

---

## Lock

```
트랜잭션 처리의 순차성을 보장하기 위한 방법
```

서로 다른 작업에서 같은 자원을 동시에 필요로 할 때 자원 경쟁이 일어나는데, 이때 순서대로 사용되는 동시성을 보장하기 위한 기능

### Lock의 종류

공유(Shared) Lock과 베타(Exclusive) Lock이 존재

#### 공유 Lock

```
데이터를 읽을 때 사용되어지는 Lock
```

- 공유 Lock은 공유 Lock끼리 동시에 접근이 가능
  하나의 데이터를 읽는 것은 여러 사용자가 동시에 할 수 있다라는 것이다.
  하지만 공유 Lock이 설정된 데이터에 베타 Lock을 사용할 수 없다.

---

#### 베타 Lock

```
데이터를 변경하고자 할 때 사용
```

- Lock이 해제될 때 까지 다른 트랜잭션(읽기 포함)은 해당 리소스에 접근할 수 없다.
  또한 해당 Lock은 다른 트랜잭션이 수행되고 있는 데이터에 대해서는 접근하여 함께 Lock을 설정할 수 없다.

---

### Lock의 설정 범위 (Level)

#### 데이터베이스

```
데이터베이스 범위의 Lock은 전체 데이터베이스를 기준으로 lock을 설정
```

즉, 1개의 세션만이 DB의 데이터에 접근이 가능

> 해당 기능은 일반적으론 사용 X
> 사용하는 때가 있다면 DB의 소프트웨어 버전을 올린다던지 주요한 DB의 업데이트에 사용

#### 파일

```
데이터베이스 파일을 기준으로 Lock을 설정
```

> 파일: 테이블, row 등과 같은 실제 데이터가 쓰여지는 물리적인 저장소
> 해당 범위의 Lock은 잘 사용되지 않음

#### 테이블

```
테이블을 기준으로 Lock을 설정
```

이는 테이블의 모등 행을 업데이트 하는 등의 전체 테이블에 영향을 주는 변경을 수행할 때 유용

> 즉 DDL(create, alter, drop 등) 구문과 함께 사용되며 DDL Lock이라고도 함

#### 페이지와 블럭

```
파일의 일부인 페이지와 블록을 기준으로 Lock을 설정
```

> 잘 사용되지 않음

#### 컬럼

```
컬럼을 기준으로 Lock을 설정
```

하지만 이 형식은 Lock 설정 및 해제의 리소스가 많이 들기 때문에 일반적으로 사용되진 않음, 지원하는 DBMS도 많지 않음

#### 행(Row)

```
1개의 행(Row)를 기준으로 Lock을 설정
```

DML에 대한 Lock으로 가장 일반적으로 사용하는 Lock

---

### 블로킹

```
Lock간(베타 - 베타, 베타 - 공유)의 경합이 발생하여 특정 Transaction이 작업을 진행하지 못하고 멈춰선 상태
```

공유 Lock끼린 블로킹이 발생하지 않지만 베타 Lock은 블로킹을 발생 시킴

> 블로킹을 해소하기 위해서는 이전의 트랜잭션이 완료(커밋 OR 롤백)되어야 한다.
> 뒤에 들어온 트랜잭션은 이전 트랜잭션이 마무리되어야 이후 진행이 가능하다.
> 이런 경합은 성능에 좋지않은 영향을 미쳐 경합을 최소화 할 필요가 있다.

---

### 교착상태 (DeadLock)

```
두 트랜잭션이 각각 Lock을 설정하고 다음 서로의 Lock에 접근하여 값을 얻어오려고 할 때
이미 각각의 트랜잭션에 의해 Lock이 설정되어 있기 때문에
양쪽 트랜잭션 모두 영원히 처리가 되지않게 되는 상태
```

![](https://velog.velcdn.com/images/blooper20/post/e4b8fcc4-7933-4db5-9d2a-6c7ae0b3bb03/image.png)

> 교착상태가 발생하면 DBMS가 둘 중 한 트랜잭션에 에러를 발생시킴으로써 문제를 해결
> **교착상태가 발생할 가능성을 줄이기 위해선 접근 순서를 동일하게 하는것이 중요**

## 트랜잭션 연산 및 상태

### 트랜잭션의 연산

#### Commit 연산

1. Commit 연산은 한개의 논리적 단위(트랜잭션)에 대한 작업이 성공적으로 끝났고 데이터베이스가 다시 일관된 상태에 있을 때, 이 트랜잭션이 행한 갱신이 완료된 것을 트랜잭션 관리자에게 알려주는 연산이다.

---

#### Rollback 연산

1. Rollback 연산은 하나의 트랜잭션 처리가 비정상적으로 종료되어 데이터베이스의 일관성을 깨뜨렸을 때, 이 트랜잭션의 일부가 정상적으로 처리되었더라도 트랜잭션의 원자성을 구현하기 위해 이 트랜잭션이 행한 모든 연산을 취소(Undo)하는 연산이다.

---

### 트랜잭션의 상태

![](https://velog.velcdn.com/images/blooper20/post/753b8826-ab2f-4d8b-a53f-e13fc350ef83/image.png)활동(Active): 트랜잭션이 실행중인 상태
실패(Failed): 트랜잭션 실행에 오류가 발생하여 중단된 상태
철회(Aborted): 트랜잭션이 비정상적으로 종료되어 Rollback 연산을 수행한 상태
부분 완료(Partially Committed): 트랜잭션의 마지막 연산까지 실행했지만, Commit 연산이 실행되기 직전의 상태
완료(Committed): 트랜잭션이 성공적으로 종료되어 Commit 연산을 실행한 후의 상태

---

## 트랜잭션을 사용할 때 주의할 점

- 반드시 필요한 상황에서만 최소한으로 적용해야 하며 이는 트랜잭션 범위를 최소화를 의미
- 데이터베이스의 커넥션의 수는 정해져 있는데 각각의 단위 프로그램이 커넥션을 오랫동안 가지고 있으면 사용 가능한 커넥션의 수가 줄어듬
- 커넥션의 수가 계속 줄어들면 사용 가능한 커넥션을 기다려야 하는 경우도 발생

---

# 참고한 블로그 링크

- https://coding-factory.tistory.com/226
- https://sabarada.tistory.com/121
- https://developer-ellen.tistory.com/185
